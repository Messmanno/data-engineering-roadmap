1ï¸âƒ£ Les Listes â€” la base de toute collection ordonnÃ©e
ğŸ’¡ DÃ©finition :

Une liste est une collection ordonnÃ©e et modifiable dâ€™Ã©lÃ©ments.
Les Ã©lÃ©ments peuvent Ãªtre de types diffÃ©rents (entiers, chaÃ®nes, flottants, etc.).

# CrÃ©ation d'une liste
fruits = ["pomme", "banane", "mangue"]

# Liste mixte
infos = ["Alice", 25, True]

ğŸ”¹ AccÃ©der aux Ã©lÃ©ments :
print(fruits[0])     # pomme
print(fruits[-1])    # mangue (index nÃ©gatif = depuis la fin)

ğŸ”¹ Modifier des Ã©lÃ©ments :
fruits[1] = "orange"
print(fruits)  # ['pomme', 'orange', 'mangue']

ğŸ”¹ Fonctions utiles :
fruits.append("ananas")     # ajoute Ã  la fin
fruits.insert(1, "kiwi")    # insÃ¨re Ã  une position
fruits.remove("orange")     # supprime un Ã©lÃ©ment
fruits.pop()                # supprime le dernier
print(len(fruits))          # longueur de la liste

ğŸ”¹ ItÃ©ration :
for fruit in fruits:
    print(fruit)

ğŸ”¹ List comprehension (trÃ¨s utilisÃ©e en data) :
nombres = [1, 2, 3, 4, 5]
carres = [x**2 for x in nombres]
print(carres)  # [1, 4, 9, 16, 25]


ğŸ‘‰ Astuce Data :
Tu peux filtrer directement :

pairs = [x for x in nombres if x % 2 == 0]

ğŸ”¹ Fonctions courantes :
Fonction	Description
sum(liste)	Somme des Ã©lÃ©ments
max(liste) / min(liste)	Valeurs extrÃªmes
sorted(liste)	Tri croissant
liste.sort(reverse=True)	Tri en place (dÃ©croissant possible)
liste.count(x)	Compte le nombre dâ€™occurrences

************************************************************************************************************************
2ï¸âƒ£ Les Dictionnaires â€” les bases de donnÃ©es miniatures
ğŸ’¡ DÃ©finition :

Un dictionnaire stocke des paires clÃ© : valeur.
Câ€™est non ordonnÃ© (avant Python 3.7) et modifiable.

etudiant = {
    "nom": "Ali",
    "age": 22,
    "filiere": "Data Science"
}

ğŸ”¹ AccÃ¨s et modification :
print(etudiant["nom"])      # Ali
etudiant["age"] = 23        # modification
etudiant["email"] = "ali@gmail.com"  # ajout

ğŸ”¹ MÃ©thodes utiles :
print(etudiant.keys())      # dict_keys(['nom', 'age', 'filiere', 'email'])
print(etudiant.values())    # dict_values([...])
print(etudiant.items())     # liste de tuples (clÃ©, valeur)

ğŸ”¹ Suppression :
etudiant.pop("email")
del etudiant["filiere"]

ğŸ”¹ ItÃ©ration :
for cle, valeur in etudiant.items():
    print(cle, ":", valeur)

ğŸ”¹ Dictionnaire imbriquÃ© :
classe = {
    "Ali": {"note": 14, "age": 22},
    "Sara": {"note": 17, "age": 21}
}

print(classe["Sara"]["note"])  # 17

ğŸ”¹ Dictionnaire par comprÃ©hension :
nombres = [1, 2, 3, 4]
carres = {x: x**2 for x in nombres}
print(carres)  # {1:1, 2:4, 3:9, 4:16}

************************************************************************************************************************
3ï¸âƒ£ Les Sets (ensembles) â€” la collection sans doublons
ğŸ’¡ DÃ©finition :

Un set est une collection non ordonnÃ©e et sans doublons.

langages = {"Python", "Java", "C++", "Python"}
print(langages)  # {'Python', 'Java', 'C++'} (pas de doublons)

ğŸ”¹ Ajout / suppression :
langages.add("Go")
langages.remove("Java")

ğŸ”¹ OpÃ©rations dâ€™ensemble (puissance des sets) :
A = {1, 2, 3, 4}
B = {3, 4, 5, 6}

print(A | B)   # union â†’ {1,2,3,4,5,6}
print(A & B)   # intersection â†’ {3,4}
print(A - B)   # diffÃ©rence â†’ {1,2}
print(A ^ B)   # diffÃ©rence symÃ©trique â†’ {1,2,5,6}

ğŸ”¹ VÃ©rifier lâ€™appartenance :
if "Python" in langages:
    print("Oui, Python est prÃ©sent !")

************************************************************************************************************************
| Structure        | OrdonnÃ©e                  | Modifiable   | Doublons   | AccÃ¨s par     |
| ---------------- | ------------------------- | ----------   | --------   | --------------|
| **Liste**        | âœ… Oui                     | âœ… Oui      | âœ… Oui    | Index          |
| **Dictionnaire** | âœ… Oui (depuis Python 3.7) | âœ… Oui      | âŒ Non    | ClÃ©            |
| **Set**          | âŒ Non                     | âœ… Oui      | âŒ Non    | Valeur directe |
************************************************************************************************************************
ğŸ§  COURS PYTHON â€” *args et **kwargs
ğŸ”¹ 1ï¸âƒ£ Pourquoi utiliser *args et **kwargs ?

Par dÃ©faut, une fonction prend un nombre fixe de paramÃ¨tres.

Exemple classique :

def addition(a, b):
    return a + b

print(addition(2, 3))  # 5


Mais si tu veux additionner 3, 4, 10 ou 100 nombres, tu devrais redÃ©finir ta fonction Ã  chaque fois.
ğŸ‘‰ Solution : utiliser des arguments variables avec *args et **kwargs.

ğŸ”¸ 2ï¸âƒ£ *args â€” les arguments positionnels variables
ğŸ’¡ DÃ©finition :

*args permet de passer un nombre illimitÃ© dâ€™arguments positionnels Ã  une fonction.
Ils sont stockÃ©s sous forme de tuple.

Exemple :
def addition(*args):
    print(args)

addition(2, 4, 6)


ğŸ“¤ RÃ©sultat :

(2, 4, 6)


Tu peux ensuite les parcourir :

def addition(*args):
    return sum(args)

print(addition(1, 2, 3, 4))  # 10

âš™ï¸ Explication :

*args â†’ Â« * Â» dÃ©compresse les arguments en liste de valeurs

args est un nom conventionnel, mais tu pourrais lâ€™appeler *nombres, par exemple :

def afficher(*nombres):
    for n in nombres:
        print(n)

Autres exemples :
def concatener(*mots):
    return " ".join(mots)

print(concatener("Data", "Science", "avec", "Python"))
# RÃ©sultat : Data Science avec Python

ğŸ§  Astuce :

Tu peux combiner *args avec des arguments normaux :

def saluer(prenom, *messages):
    print(f"Bonjour {prenom} !")
    for msg in messages:
        print("-", msg)

saluer("Ali", "Comment Ã§a va ?", "PrÃªt pour le cours ?")

ğŸ”¸ 3ï¸âƒ£ **kwargs â€” les arguments nommÃ©s variables
ğŸ’¡ DÃ©finition :

**kwargs permet de passer un nombre illimitÃ© dâ€™arguments nommÃ©s (clÃ©=valeur).
Ils sont stockÃ©s sous forme de dictionnaire.

Exemple :
def afficher_infos(**kwargs):
    print(kwargs)

afficher_infos(nom="Ali", age=25, pays="CÃ´te dâ€™Ivoire")


ğŸ“¤ RÃ©sultat :

{'nom': 'Ali', 'age': 25, 'pays': 'CÃ´te dâ€™Ivoire'}

Tu peux parcourir le dictionnaire :
def afficher_infos(**kwargs):
    for cle, valeur in kwargs.items():
        print(f"{cle} : {valeur}")

afficher_infos(nom="Sara", domaine="Data", niveau="IntermÃ©diaire")


ğŸ“¤ RÃ©sultat :

nom : Sara
domaine : Data
niveau : IntermÃ©diaire

ğŸ§  Exemple concret :
def creer_profil(**infos):
    profil = {"id": 1}
    profil.update(infos)
    return profil

print(creer_profil(nom="Ali", ville="Abidjan"))
# {'id': 1, 'nom': 'Ali', 'ville': 'Abidjan'}

ğŸ”¹ 4ï¸âƒ£ Combinaison *args et **kwargs

Tu peux les combiner dans une mÃªme fonction ğŸ‘‡

def exemple(a, b, *args, **kwargs):
    print("a =", a)
    print("b =", b)
    print("args =", args)
    print("kwargs =", kwargs)

exemple(1, 2, 3, 4, 5, nom="Ali", age=23)


ğŸ“¤ RÃ©sultat :

a = 1
b = 2
args = (3, 4, 5)
kwargs = {'nom': 'Ali', 'age': 23}


âš ï¸ Ordre Ã  respecter :

def fonction(paramÃ¨tres_pos, *args, paramÃ¨tres_nommes_defaut, **kwargs)

ğŸ”¹ 5ï¸âƒ£ DÃ©ballage (unpacking) avec * et **
ğŸ’¡ DÃ©baller une liste dans une fonction :
def addition(a, b, c):
    return a + b + c

nombres = [1, 2, 3]
print(addition(*nombres))  # 6

ğŸ’¡ DÃ©baller un dictionnaire :
def saluer(nom, age):
    print(f"Salut {nom}, tu as {age} ans.")

infos = {"nom": "Ali", "age": 25}
saluer(**infos)

************************************************************************************************************************
ğŸ§  COURS PYTHON â€” GÃ©nÃ©rateurs & Modules
ğŸŒ€ PARTIE 1 : LES GÃ‰NÃ‰RATEURS
ğŸ”¹ 1ï¸âƒ£ Quâ€™est-ce quâ€™un gÃ©nÃ©rateur ?

Un gÃ©nÃ©rateur est une fonction spÃ©ciale qui ne retourne pas toutes ses valeurs dâ€™un coup, mais les produit une Ã  une, Ã  la demande.
ğŸ‘‰ Cela permet dâ€™Ã©conomiser de la mÃ©moire et de gÃ©rer de grandes quantitÃ©s de donnÃ©es efficacement (fichiers, gros jeux de donnÃ©es, fluxâ€¦).

ğŸ”¹ 2ï¸âƒ£ DiffÃ©rence entre fonction normale et gÃ©nÃ©rateur
ğŸ§© Fonction classique :
def carre_normale(n):
    result = []
    for i in range(n):
        result.append(i**2)
    return result

print(carre_normale(5))  # [0, 1, 4, 9, 16]


Cette fonction crÃ©e toute la liste en mÃ©moire avant de la renvoyer.

âš™ï¸ GÃ©nÃ©rateur Ã©quivalent :
def carre_gen(n):
    for i in range(n):
        yield i**2

for val in carre_gen(5):
    print(val)


ğŸ“¤ RÃ©sultat :

0
1
4
9
16

ğŸ”¹ 3ï¸âƒ£ Le mot-clÃ© yield

yield remplace return.

Il met la fonction en pause et garde son Ã©tat.

Quand on rappelle le gÃ©nÃ©rateur, lâ€™exÃ©cution reprend lÃ  oÃ¹ elle sâ€™Ã©tait arrÃªtÃ©e.

ğŸ”¹ 5ï¸âƒ£ Les gÃ©nÃ©rateurs avec comprÃ©hension

Tu peux crÃ©er un gÃ©nÃ©rateur en une ligne (comme une list comprehension) :

gen = (x**2 for x in range(5))
print(next(gen))  # 0
print(next(gen))  # 1


ğŸ“¦ PARTIE 2 : LES MODULES EN PYTHON
ğŸ”¹ 1ï¸âƒ£ Quâ€™est-ce quâ€™un module ?

Un module est un fichier Python (.py) qui contient des fonctions, classes ou variables quâ€™on peut rÃ©utiliser dans dâ€™autres programmes.

ğŸ‘‰ Câ€™est la base de la modularitÃ© et de la rÃ©utilisation du code en Python.

ğŸ”¹ 2ï¸âƒ£ CrÃ©er ton propre module
Ã‰tape 1 â€” CrÃ©e un fichier :

ğŸ“„ mon_module.py

def saluer(nom):
    return f"Bonjour {nom} !"

PI = 3.14159

Ã‰tape 2 â€” Utiliser ton module :

ğŸ“„ programme.py

import mon_module

print(mon_module.saluer("Ali"))
print(mon_module.PI)


ğŸ“¤ RÃ©sultat :

Bonjour Ali !
3.14159

ğŸ”¹ 3ï¸âƒ£ Importer seulement ce dont tu as besoin
from mon_module import saluer

print(saluer("Sara"))

ğŸ”¹ 4ï¸âƒ£ Renommer un module importÃ©
import mon_module as mm
print(mm.saluer("Moussa"))

ğŸ”¹ 5ï¸âƒ£ Importer plusieurs modules
import math
import random

print(math.sqrt(16))  # 4.0
print(random.randint(1, 10))  # nombre alÃ©atoire entre 1 et 10

ğŸ”¹ 6ï¸âƒ£ Les modules standards Python (trÃ¨s utilisÃ©s en Data)
Module	Utilisation principale
math	Fonctions mathÃ©matiques
random	GÃ©nÃ©ration alÃ©atoire
os	Gestion du systÃ¨me de fichiers
sys	Interaction avec le systÃ¨me
datetime	Dates et heures
json	Lire/Ã©crire des fichiers JSON
csv	Manipulation de fichiers CSV
collections	Structures avancÃ©es (Counter, defaultdict)
Exemple concret :
import csv

with open('data.csv', newline='') as fichier:
    lecteur = csv.reader(fichier)
    for ligne in lecteur:
        print(ligne)

ğŸ”¹ 7ï¸âƒ£ Les packages

Un package est un dossier contenant plusieurs modules avec un fichier __init__.py.

mon_package/
â”‚
â”œâ”€â”€ __init__.py
â”œâ”€â”€ calculs.py
â””â”€â”€ affichage.py


Exemple :

from mon_package.calculs import addition

ğŸ”¹ 8ï¸âƒ£ CrÃ©er ton propre package (exercice dâ€™organisation)

CrÃ©e un dossier outil_data

Ajoute :

nettoyage.py (pour fonctions de nettoyage de texte)

analyse.py (pour fonctions de moyenne et Ã©cart-type)

__init__.py

Importe ces modules dans un script principal

ğŸ§  Exercice pratique sur les modules :

CrÃ©e un module statistiques.py contenant :

def moyenne(liste):
    return sum(liste) / len(liste)

def variance(liste):
    m = moyenne(liste)
    return sum((x - m)**2 for x in liste) / len(liste)


Importe-le dans un autre fichier et calcule :

from statistiques import moyenne, variance

data = [10, 12, 14, 16]
print(moyenne(data))
print(variance(data))

ğŸ§¾ RÃ©sumÃ© du cours
Concept	Description	Avantage
GÃ©nÃ©rateur	Fonction qui renvoie une valeur Ã  la fois avec yield	Ã‰conome en mÃ©moire
yield	Met la fonction en pause et reprend plus tard	GÃ¨re des flux continus
Module	Fichier Python rÃ©utilisable	Code organisÃ©
Package	Dossier regroupant plusieurs modules	Organisation Ã  grande Ã©chelle